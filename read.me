Perfeito. Suas respostas são excelentes e abordam os pontos de falha mais comuns em sistemas de trade automatizado. Isso demonstra um ótimo entendimento dos riscos operacionais.

Incorporei suas diretrizes diretamente no nosso roadmap, criando uma versão 2.0 que é significativamente mais robusta e segura. Os itens adicionados ou modificados estão marcados com [NOVO/REFINADO] para que você possa identificá-los facilmente.

Roadmap de Desenvolvimento v2.0: Robô de Trade para Binance (Aprimorado)
Fase 0: Setup do Ambiente e Fundamentos (Inalterado)
[x] 1. Inicialização do Projeto: (npm init -y, git init).

[x] 2. Instalação de Dependências Essenciais: (mysql2, sequelize, dotenv, node-binance-api, technicalindicators, node-cron, decimal.js).

[x] 3. Configuração do Banco de Dados (MySQL):
- HOST: easypanel.techpulsar.com.br
- USER: dados_operacoes
- PASSWORD: d428c8cb50dfb03d1613
- DATABASE: cripto_binance
- PORT: 3023

[x] Schema da tabela trades (id, pair, orderId, entry_price, quantity, status, etc.).

[x] 4. Módulos de Conexão: (Binance API, Sequelize DB).

Fase 1: O Motor de Análise (Coleta e Cálculo)
[x] 1. Coleta de Dados de Mercado:

[x] Implementar função para buscar todos os pares com sufixo USDT.

[x] Implementar função fetchCandles(pair, interval) para buscar o histórico de velas.

[x] [NOVO/REFINADO] Implementar função getAccountBalance() que busca e retorna o saldo USDT disponível na conta.

[x] 2. Motor de Indicadores:

[x] Implementar função calculateIndicators(candles) que retorna Supertrend, Média de 3 mínimas e Média de 5 máximas.

Fase 2: Lógica de Decisão e Alocação de Capital
[x] 1. Implementação do Scheduler (node-cron):

[x] Configurar para executar a rotina principal a cada hora.

[x] 2. Rotina Principal (main_function):

[x] Passo 1: [NOVO/REFINADO] Chamar getAccountBalance() e calcular o capital total para a rodada de trades (capital_disponivel = saldo_USDT * 0.90).

[x] Passo 2: Buscar a lista de todos os pares USDT.

[x] Passo 3: Iniciar um loop por cada par para identificar oportunidades.

[x] Passo 4: Dentro do loop, consultar o DB para verificar se já existe posição aberta (isPositionOpen(pair)). Se sim, pular.

[x] Passo 5: Se não, buscar candles, calcular indicadores e verificar a condição de entrada (last_close > supertrend && last_close < sma_low).

[x] Passo 6: [NOVO/REFINADO] Se a condição for atendida, adicionar o par a uma lista de candidatos_a_compra.

[x] Passo 7: [NOVO/REFINADO] Após analisar todos os pares, iniciar um novo loop na lista candidatos_a_compra.

Para cada candidato, verificar se capital_disponivel >= 12 USDT.

Se sim, executar a compra de 12 USDT.

Deduzir o valor da compra do capital_disponivel.

Continuar até que capital_disponivel < 12 USDT ou a lista de candidatos acabe.

Isso garante que o robô use o saldo de forma eficiente e segura, sempre com a informação mais atualizada do capital.

Fase 3: Execução de Ordens e Gerenciamento de Estado (Mais Robusto)
[x] 1. [NOVO/REFINADO] Rotina de Inicialização e Sincronização:

[x] Esta função deve rodar UMA VEZ sempre que o robô for iniciado.

[x] Passo 1: Buscar todas as ordens com status OPEN no banco de dados local.

[x] Passo 2: Chamar a API da Binance para obter a lista de todas as ordens em aberto na conta (getOpenOrders).

[x] Passo 3: Comparar as duas listas:

Se uma ordem está no DB mas não na Binance (foi fechada manualmente), atualizar o status no DB para CLOSED_MANUALLY.

Se uma ordem está na Binance mas não no DB (criada manualmente), ignorar ou logar um aviso.

Se a ordem existe em ambos, prosseguir normalmente.

[x] Passo 4: Somente após a sincronização, iniciar o monitoramento de saída via WebSocket para as ordens que continuam válidas e abertas.

[x] 2. Funções de Ordem (Compra/Venda):

[x] Implementar placeBuyOrder(pair, amountInUSDT) com tratamento de precisão (stepSize, tickSize) e gestão de erros.

[x] Implementar placeSellOrder(pair, quantity).

[x] 3. Persistência de Trades:

[x] Após compra bem-sucedida, inserir a trade no DB com status OPEN.

[x] 4. Monitoramento de Saída (WebSockets):

[x] Implementar startExitMonitoring() que, para cada trade OPEN, abre um WebSocket e aciona a venda quando o preço superar a sma_high(5).

[x] 5. Finalização de Trade:

[x] Ao vender com sucesso, atualizar o registro no DB (status = 'CLOSED', preencher exit_price, profit_loss, etc.) e fechar o WebSocket correspondente.